/******************************************************************************
 * Name:        bintilecreator.cpp
 * Purpose:     Supertile Self-assembly Simulator data creator: binary tile set
 * Author:      Yunhui Fu
 * Created:     2009-08-29
 * Modified by:
 * RCS-ID:      $Id: $
 * Copyright:   (c) 2009 Yunhui Fu
 * Licence:     GPL licence version 3
 ******************************************************************************/

#include <assert.h>
#include <getopt.h>
#include <math.h>
#include <stdlib.h> // atoi()
#include <stdio.h>
#include <string.h>

#define VERSION_MAJOR 0
#define VERSION_MINOR 1

#define XML_VERSION_MAJOR 0
#define XML_VERSION_MINOR 1

// test: logn=4,3,2,1 时的

/*
Binary Counter Tiles

   |1
r +--+ r
--|1H|--
  +--+
   ||
r +--+ p
--|0H|--
  +--+
   |0

   |C0
p +--+
--|1C|-- h1
  +--+
   ||C1
r +--+
--|0C|-- h2
  +--+
   |C0

   |0
r +--+ r
--|0R|--
  +--+
   |d

   |d
p +--+ p
--|1P|--
  +--+
   |1

   |0
f +--+ f
--|0 |--
  +--+
   |0

   |1
f +--+ f
--|1 |--
  +--+
   |1

Binary starter
1)
                 |1
              r +--+ r
              --|1H|--
                +--+
                 ||
   |0     |1     ||     |d     |d     |C0
  +--+   +--+ f +--+ p +--+ p +--+   +--+
  |0 |===|1 |---|0H|---|1 |---|1 |===|1 |
  +--+   +--+   +--+   +--+   +--+   +--+

2)
                                      |C0
                                   p +--+
                                   --|1C|-- h1
                                     +--+
                                      ||
   |0     |1     |0     |1     |1     ||C1
  +--+   +--+ f +--+ f +--+ f +--+   +--+
  |0 |===|1 |---|0 |---|1 |---|1 |===|0 |
  +--+   +--+   +--+   +--+   +--+   +--+

3)

   ||     |1
  +--+   +--+
  |0H|===|1 |
  +--+   +--+

*/

// 转化01字符串上的第几位为数值
// 注意先后顺序，字符串的0位是数值的最高位
// 如 "0000000000001" 的第0位是数值1
int
strbit2val (char * startbinary, size_t pos)
{
    size_t max;
    if (NULL == startbinary) {
        return 0;
    }
    max = strlen (startbinary);
    if (max == 0) {
        return 0;
    }
    max --;
    if (pos > max) {
        return 0;
    }
    switch (startbinary[max - pos]) {
    case '0':
        return 0;
        break;
    case '1':
        return 1;
        break;
    }
    return -1;
}

int
out_bintile (size_t bits, char * startbinary, size_t max_num_tiles, size_t temperature, const char *fname)
{
    char flg_norotate = 1;
    size_t steps_1year_min = 10;
    size_t steps_1year_max = 100;
    size_t year_current = 0;

    size_t i;
    size_t idx;
    size_t idx_cur;
    size_t sz_tilelist;
    size_t cnt;
    size_t times_square;
    FILE *fp_xml = NULL;
    size_t x, y;
    size_t val;
    char flg_carrier;

    int glue_tight;
    int glue_north;
    int glue1, glue2, glue4;

    int glue_0;
    int glue_1;
    int glue_f;
    int glue_r;
    int glue_p;
    int glue_d;
    int glue_c0;
    int glue_h1;
    int glue_h2;
    int glue_c1;
    int glue_2_carry;

    int tile_1h;
    int tile_0h;
    int tile_1c;
    int tile_0c;
    int tile_0;
    int tile_1;
    int tile_0r;
    int tile_1p;
    int tile_pos_0;

    int type_north[4];
    memset (type_north, 0, sizeof (type_north));

    if (bits < 1) {
        fprintf (stderr, "the Bit(%d) should be >= 1\n", bits);
        return -1;
    }
    if (temperature < 2) {
        fprintf (stderr, "the temperture(%d) should be >= 2\n", temperature);
        return -1;
    }
    times_square = max_num_tiles / (size_t)(pow (2, bits) /*- startbinary*/);
    if (times_square < 5) {
        times_square = 5;
    }
    fprintf (stderr, "the times of bintile of type (bits:%d, start:%s): %d\n", bits, startbinary, times_square);

    fp_xml = fopen (fname, "w");
    if (NULL == fp_xml) {
        return -1;
    }

    fprintf (fp_xml, "<?xml version='1.0' encoding='utf-8' ?>\n");
    fprintf (fp_xml, "<!-- Auto-generated by the cube creator. -->\n");
    fprintf (fp_xml, "<tilesim>\n  <version>\n    <major>%d</major>\n    <minor>%d</minor>\n  </version>\n", XML_VERSION_MAJOR, XML_VERSION_MINOR);
    //tssim_save_encoding_3d (fp_xml);

    fprintf (fp_xml, "  <temperature>%d</temperature>\n", temperature);
    fprintf (fp_xml, "  <rotatable>%s</rotatable>\n", ((0 == flg_norotate)?"true":"false"));

    assert (((0 != steps_1year_max) && (steps_1year_max > steps_1year_min)) || (0 == steps_1year_max));
    fprintf (fp_xml, "  <simulationsetup>\n");
    fprintf (fp_xml, "    <currentyear>%d</currentyear>\n", year_current);
    fprintf (fp_xml, "    <stepsmin>%d</stepsmin>\n", steps_1year_min);
    fprintf (fp_xml, "    <stepsmax>%d</stepsmax>\n", steps_1year_max);
    fprintf (fp_xml, "  </simulationsetup>\n");

    // the glue of strenth 0
    idx = 0;
    fprintf (fp_xml,
        "  <glue> <!-- null glue -->\n"
        "    <id>%d</id>\n"
        "    <strength>%d</strength>\n"
        "  </glue>\n"
        , idx, 0);
    idx ++;

    glue_tight = idx;
    fprintf (fp_xml,
        "  <glue> <!-- strong glue -->\n"
        "    <id>%d</id>\n"
        "    <strength>%d</strength>\n"
        "  </glue>\n"
        , idx, temperature);
    idx ++;

    // the glues strength=1
    //0,1,f,r,p,d
    glue_0=idx;
    glue_1=idx+1;
    glue_f=idx+2;
    glue_r=idx+3;
    glue_p=idx+4;
    glue_d=idx+5;
    glue_c0=idx+6;
    glue_h1=idx+7;
    glue_h2=idx+8;
    for (i = 0; i < 9; i ++) {
        fprintf (fp_xml,
            "  <glue> <!-- common glue -->\n"
            "    <id>%d</id>\n"
            /*"    <name>%d</name>\n"*/
            "    <strength>%d</strength>\n"
            "  </glue>\n"
            , idx + i, (temperature + 1) / 2);
    }
    assert (i == 9);
    idx += i;

    // glue between the two tiles of ?
    glue_2_carry = idx;
    fprintf (fp_xml,
        "  <glue> <!-- glue between 1h & 0h -->\n"
        "    <id>%d</id>\n"
        "    <strength>%d</strength>\n"
        "  </glue>\n"
        , idx, temperature);
    idx ++;

    // glue between the two tiles of ?
    glue_c1 = idx;
    fprintf (fp_xml,
        "  <glue> <!-- glue between 1c & 0c -->\n"
        "    <id>%d</id>\n"
        "    <strength>%d</strength>\n"
        "  </glue>\n"
        , idx, temperature);
    idx ++;

    idx = 0;
    // the tile 1H
    tile_1h = idx;
    fprintf (fp_xml,
        "  <tile>\n"
        "    <id>%d</id>\n"
        "    <label>%s</label>\n"
        "    <north>%d</north>\n"
        "    <east>%d</east>\n"
        "    <south>%d</south>\n"
        "    <west>%d</west>\n"
        "  </tile>\n"
        , idx, "1h", glue_1, glue_r, glue_2_carry, glue_f);
    idx ++;
    // the tile 0H
    tile_0h = idx;
    fprintf (fp_xml,
        "  <tile>\n"
        "    <id>%d</id>\n"
        "    <label>%s</label>\n"
        "    <north>%d</north>\n"
        "    <east>%d</east>\n"
        "    <south>%d</south>\n"
        "    <west>%d</west>\n"
        "  </tile>\n"
        , idx, "0h", glue_2_carry, glue_p, glue_0, glue_f);
    idx ++;

    // the tile 1C
    tile_1c = idx;
    fprintf (fp_xml,
        "  <tile>\n"
        "    <id>%d</id>\n"
        "    <label>%s</label>\n"
        "    <north>%d</north>\n"
        "    <east>%d</east>\n"
        "    <south>%d</south>\n"
        "    <west>%d</west>\n"
        "  </tile>\n"
        , idx, "1c", glue_c0, glue_h1, glue_c1, glue_p);
    idx ++;
    // the tile 0C
    tile_0c = idx;
    fprintf (fp_xml,
        "  <tile>\n"
        "    <id>%d</id>\n"
        "    <label>%s</label>\n"
        "    <north>%d</north>\n"
        "    <east>%d</east>\n"
        "    <south>%d</south>\n"
        "    <west>%d</west>\n"
        "  </tile>\n"
        , idx, "0c", glue_c1, glue_h2, glue_c0, glue_r);
    idx ++;
    // the tile 0R
    tile_0r = idx;
    fprintf (fp_xml,
        "  <tile>\n"
        "    <id>%d</id>\n"
        "    <label>%s</label>\n"
        "    <north>%d</north>\n"
        "    <east>%d</east>\n"
        "    <south>%d</south>\n"
        "    <west>%d</west>\n"
        "  </tile>\n"
        , idx, "0r", glue_0, glue_r, glue_d, glue_r);
    idx ++;
    // the tile 1P
    tile_1p = idx;
    fprintf (fp_xml,
        "  <tile>\n"
        "    <id>%d</id>\n"
        "    <label>%s</label>\n"
        "    <north>%d</north>\n"
        "    <east>%d</east>\n"
        "    <south>%d</south>\n"
        "    <west>%d</west>\n"
        "  </tile>\n"
        , idx, "1p", glue_d, glue_p, glue_1, glue_p);
    idx ++;
    // the tile 0
    tile_0 = idx;
    fprintf (fp_xml,
        "  <tile>\n"
        "    <id>%d</id>\n"
        "    <label>%s</label>\n"
        "    <north>%d</north>\n"
        "    <east>%d</east>\n"
        "    <south>%d</south>\n"
        "    <west>%d</west>\n"
        "  </tile>\n"
        , idx, "0", glue_0, glue_f, glue_0, glue_f);
    idx ++;
    // the tile 1
    tile_1 = idx;
    fprintf (fp_xml,
        "  <tile>\n"
        "    <id>%d</id>\n"
        "    <label>%s</label>\n"
        "    <north>%d</north>\n"
        "    <east>%d</east>\n"
        "    <south>%d</south>\n"
        "    <west>%d</west>\n"
        "  </tile>\n"
        , idx, "1", glue_1, glue_f, glue_1, glue_f);
    idx ++;

    // the tiles of the start point right corner
    tile_pos_0 = idx;
    val = strbit2val (startbinary, 0);
    flg_carrier = val;
    type_north[0] = ((0==val)?glue_c1:glue_c0);
    fprintf (fp_xml,
        "  <tile> <!-- tile in the corner of base -->\n"
        "    <id>%d</id>\n"
        "    <label>%s</label>\n"
        "    <north>%d</north>\n"
        "    <east>%d</east>\n"
        "    <south>%d</south>\n"
        "    <west>%d</west>\n"
        "  </tile>\n"
        , idx, "s", ((0==val)?glue_c1:glue_c0), ((0==val)?glue_h2:glue_h1), 0, glue_tight);
    idx ++;

    // the second
    idx_cur = 1;
    for (i = 1; i < bits; i ++) {
        val = strbit2val (startbinary, i);
        glue2 = glue_f; // east
        glue4 = glue_f; // west
        if (1 == val) {
            if (flg_carrier) {
                glue1 = glue_d; // north
                glue2 = glue_p; // east
                glue4 = glue_p; // west
            } else {
                glue1 = glue_1;
            }
        } else {
            if (flg_carrier) {
                glue1 = glue_2_carry;
                glue2 = glue_p; // east
                assert (idx_cur < 4);
            } else {
                glue1 = glue_0;
            }
            flg_carrier = 0;
        }
        // 前面的代码是为了判断 flg_carrier，所以直到这里才判断 i
        if ((i != 1) && (i + 1 != bits) && (i + 2 != bits)) {
            continue;
        }
        if (i == 0) {
            glue4 = glue_tight; // west
            assert (idx_cur == 0);
        } else if (i + 1 == bits) {
            glue2 = glue_tight; // east
            glue4 = 0;
            assert ((idx_cur == 3) || ((bits <=4) && (idx_cur == bits - 1)));
        } else if (i == 1) {
            glue2 = glue_tight; // east
            assert (idx_cur == 1);
        } else if (i + 2 == bits) {
            glue4 = glue_tight; // west
            assert (idx_cur == 2);
        }
        if (bits <= 4) {
            if (i + 1 != bits) {
                glue4 = glue_tight;
            }
            glue2 = glue_tight;
        }
        type_north[idx_cur] = glue1;
        fprintf (fp_xml,
            "  <tile> <!-- tile in the base -->\n"
            "    <id>%d</id>\n"
            "    <label>%d</label>\n"
            "    <north>%d</north>\n"
            "    <east>%d</east>\n"
            "    <south>%d</south>\n"
            "    <west>%d</west>\n"
            "  </tile>\n"
            , idx, val, glue1, glue2, 0, glue4);
        idx ++;
        idx_cur ++;
    }

    sz_tilelist = idx;
    // 计算各个 tile 在其中所占的比例
    idx = 0;
    for (i = 0; i < sz_tilelist; i ++) {
        if (i == tile_0) {
            cnt = pow (2, bits) * bits * times_square * 2 / 3;
        } else if (i == tile_1) {
            cnt = pow (2, bits) * bits * times_square * 2 / 3;
        } else if (i == tile_0r) {
            cnt = pow (2, bits) * bits * times_square * 2 / 3;
        } else if (i == tile_1p) {
            cnt = pow (2, bits) * bits * times_square * 2 / 3;
#if USE_SINGLE
        } else if (i == tile_1h) {
            cnt = pow (2, bits) * bits * times_square / 2;
        } else if (i == tile_0h) {
            cnt = pow (2, bits) * bits * times_square / 2;
        } else if (i == tile_1c) {
            cnt = pow (2, bits) * bits * times_square / 2;
        } else if (i == tile_0c) {
            cnt = pow (2, bits) * bits * times_square / 2;
#endif
        } else {
            cnt = 1;
        }
        fprintf (fp_xml,
            "  <supertile>\n"
            "    <id>%d</id>\n"
            "    <quantity>%d</quantity>\n"
            "    <birth>%d</birth>\n"
            , idx, cnt, 0);
        fprintf (fp_xml,
            "    <tileitem>\n"
            "      <id>%d</id>\n"
            "      <tileid>%d</tileid>\n"
            "      <rotnum>%d</rotnum>\n"
            "      <x>%d</x>\n"
            "      <y>%d</y>\n"
            "    </tileitem>\n"
            , 0, i, 0, 0, 0);
        fprintf (fp_xml, "  </supertile>\n");
        idx ++;
    }
#if ! USE_SINGLE
    // ones place
    cnt = pow (2, bits) / 2 + 1;
    cnt *= times_square;
    fprintf (fp_xml,
        "  <supertile>\n"
        "    <id>%d</id>\n"
        "    <quantity>%d</quantity>\n"
        "    <birth>%d</birth>\n"
        , idx, cnt, 0);
    fprintf (fp_xml,
        "    <tileitem>\n"
        "      <id>%d</id>\n"
        "      <tileid>%d</tileid>\n"
        "      <rotnum>%d</rotnum>\n"
        "      <x>%d</x>\n"
        "      <y>%d</y>\n"
        "    </tileitem>\n"
        , 0, tile_0c, 0, 0, 0);
    fprintf (fp_xml,
        "    <tileitem>\n"
        "      <id>%d</id>\n"
        "      <tileid>%d</tileid>\n"
        "      <rotnum>%d</rotnum>\n"
        "      <x>%d</x>\n"
        "      <y>%d</y>\n"
        "    </tileitem>\n"
        , 1, tile_1c, 0, 0, 1);
    fprintf (fp_xml, "  </supertile>\n");
    idx ++;

    // carrier
    cnt = pow (2, bits) / 2 + 1;
    cnt *= times_square;
    fprintf (fp_xml,
        "  <supertile>\n"
        "    <id>%d</id>\n"
        "    <quantity>%d</quantity>\n"
        "    <birth>%d</birth>\n"
        , idx, cnt, 0);
    fprintf (fp_xml,
        "    <tileitem>\n"
        "      <id>%d</id>\n"
        "      <tileid>%d</tileid>\n"
        "      <rotnum>%d</rotnum>\n"
        "      <x>%d</x>\n"
        "      <y>%d</y>\n"
        "    </tileitem>\n"
        , 0, tile_0h, 0, 0, 0);
    fprintf (fp_xml,
        "    <tileitem>\n"
        "      <id>%d</id>\n"
        "      <tileid>%d</tileid>\n"
        "      <rotnum>%d</rotnum>\n"
        "      <x>%d</x>\n"
        "      <y>%d</y>\n"
        "    </tileitem>\n"
        , 1, tile_1h, 0, 0, 1);
    fprintf (fp_xml, "  </supertile>\n");
    idx ++;
#endif

do {
    // base
    val = strbit2val (startbinary, 0);
    if ((bits < 2) && (1 == val)) {
        // 为1时不会再有 tile 附上，最终只有1个tile,而之前已经分别对每种tile都至少形成了一个supertile，所以不必要再形成只有一个tile的supertile了
        break;
    }

    cnt = times_square;
    fprintf (fp_xml,
        "  <supertile> <!-- base supertile -->\n"
        "    <id>%d</id>\n"
        "    <quantity>%d</quantity>\n"
        "    <birth>%d</birth>\n"
        , idx, cnt, 0);
    idx = 0;
    flg_carrier = 0;
    idx_cur = 0;
    for (i = 0; i < bits; i ++) {
        val = strbit2val (startbinary, i);
        glue_north = 0;
        if (i == 0) {
            if (1 == val) {
                flg_carrier = 1;
            }
            idx = tile_pos_0;
            glue_north = type_north[0];
        } else {
            if (1 == val) {
                if (flg_carrier) {
                    idx = tile_1p;
                } else {
                    idx = tile_1;
                }
            } else {
                if (flg_carrier) {
                    idx = tile_0h;
                    glue_north = glue_2_carry;
                } else {
                    idx = tile_0;
                }
                flg_carrier = 0;
            }
            if (i + 1 == bits) {
                idx = sz_tilelist - 1;
                if (bits < 4) {
                    glue_north = type_north[bits - 1];
                } else {
                    glue_north = type_north[3];
                }
            } else if (i == 1) {
                idx = tile_pos_0 + 1;
                glue_north = type_north[1];
            } else if (i + 2 == bits) {
                idx = sz_tilelist - 2;
                glue_north = type_north[2];
            }
        }
        x = bits - i - 1;
        y = 0;
        fprintf (fp_xml,
            "    <tileitem>\n"
            "      <id>%d</id>\n"
            "      <tileid>%d</tileid>\n"
            "      <rotnum>%d</rotnum>\n"
            "      <x>%d</x>\n"
            "      <y>%d</y>\n"
            "    </tileitem>\n"
            , idx_cur, idx, 0, x, y);
        idx_cur ++;
        if (glue_north == glue_c1) {
            y = 1;
            idx = tile_1c;
        } else if (glue_north == glue_2_carry) {
            y = 1;
            idx = tile_1h;
        }
        if (y > 0) {
            fprintf (fp_xml,
                "    <tileitem>\n"
                "      <id>%d</id>\n"
                "      <tileid>%d</tileid>\n"
                "      <rotnum>%d</rotnum>\n"
                "      <x>%d</x>\n"
                "      <y>%d</y>\n"
                "    </tileitem>\n"
                , idx_cur, idx, 0, x, y);
            idx_cur ++;
        }
    }
    fprintf (fp_xml, "  </supertile>\n");
    idx ++;
} while (0);

    //fprintf (fp_xml, "  <targetsupertile>\n");
    //fprintf (fp_xml, "  </targetsupertile>\n");

    // test case
    fprintf (fp_xml, "  <testcases>\n");

    // tile_1h + tile_0h
    fprintf (fp_xml,
        "    <testcaseitem>\n"
        "      <supertileid_base>%d</supertileid_base>\n"
        , tile_1h);
    fprintf (fp_xml,
        "      <supertileid_test>%d</supertileid_test>\n"
        "      <testposition>\n"
        "        <tileitem> <!-- the position of the test supertile -->\n"
        "          <rotnum>%d</rotnum>\n"
        "          <x>%d</x>\n"
        "          <y>%d</y>\n"
        "        </tileitem>\n"
        , tile_0h, 0, 1, 0);
    fprintf (fp_xml,
        "        <supertile>\n"
        "          <id>%d</id>\n"
        "          <quantity>%d</quantity>\n"
        "          <birth>%d</birth>\n"
        , 0, 1, 0);
    i = 0;
    fprintf (fp_xml,
        "          <tileitem>\n"
        "            <id>%d</id>\n"
        "            <tileid>%d</tileid>\n"
        "            <rotnum>%d</rotnum>\n"
        "            <x>%d</x>\n"
        "            <y>%d</y>\n"
        "          </tileitem>\n"
        , i, tile_0h, 0, 0, 0);
    i ++;
    fprintf (fp_xml,
        "          <tileitem>\n"
        "            <id>%d</id>\n"
        "            <tileid>%d</tileid>\n"
        "            <rotnum>%d</rotnum>\n"
        "            <x>%d</x>\n"
        "            <y>%d</y>\n"
        "          </tileitem>\n"
        , i, tile_1h, 0, 0, 1);
    i ++;
    fprintf (fp_xml, "        </supertile>\n");
    fprintf (fp_xml,
        "      </testposition>\n"
        "    </testcaseitem>\n"
        );

    // tile_1c + tile_0c
    fprintf (fp_xml,
        "    <testcaseitem>\n"
        "      <supertileid_base>%d</supertileid_base>\n"
        , tile_1c);
    fprintf (fp_xml,
        "      <supertileid_test>%d</supertileid_test>\n"
        "      <testposition>\n"
        "        <tileitem> <!-- the position of the test supertile -->\n"
        "          <rotnum>%d</rotnum>\n"
        "          <x>%d</x>\n"
        "          <y>%d</y>\n"
        "          <z>%d</z>\n"
        "        </tileitem>\n"
        , tile_0c, 0, 1, 0);
    fprintf (fp_xml,
        "        <supertile>\n"
        "          <id>%d</id>\n"
        "          <quantity>%d</quantity>\n"
        "          <birth>%d</birth>\n"
        , 0, 1, 0);
    i = 0;
    fprintf (fp_xml,
        "          <tileitem>\n"
        "            <id>%d</id>\n"
        "            <tileid>%d</tileid>\n"
        "            <rotnum>%d</rotnum>\n"
        "            <x>%d</x>\n"
        "            <y>%d</y>\n"
        "          </tileitem>\n"
        , i, tile_0c, 0, 0, 0);
    i ++;
    fprintf (fp_xml,
        "          <tileitem>\n"
        "            <id>%d</id>\n"
        "            <tileid>%d</tileid>\n"
        "            <rotnum>%d</rotnum>\n"
        "            <x>%d</x>\n"
        "            <y>%d</y>\n"
        "          </tileitem>\n"
        , i, tile_1c, 0, 0, 1);
    i ++;
    fprintf (fp_xml, "        </supertile>\n");
    fprintf (fp_xml,
        "      </testposition>\n"
        "    </testcaseitem>\n"
        );

    fprintf (fp_xml, "  </testcases>\n");

    fprintf (fp_xml, "</tilesim>\n");
    fclose (fp_xml);

#if 0 // DEBUG
#define OUT_VAL(a) printf ("\t"#a": %d\n", a)

    OUT_VAL (glue_0);
    OUT_VAL (glue_1);
    OUT_VAL (glue_f);
    OUT_VAL (glue_r);
    OUT_VAL (glue_p);
    OUT_VAL (glue_d);
    OUT_VAL (glue_c0);
    OUT_VAL (glue_h1);
    OUT_VAL (glue_h2);
    OUT_VAL (glue_c1);
    OUT_VAL (glue_2_carry);

    OUT_VAL (tile_1h);
    OUT_VAL (tile_0h);
    OUT_VAL (tile_1c);
    OUT_VAL (tile_0c);
    OUT_VAL (tile_0r);
    OUT_VAL (tile_1p);
    OUT_VAL (tile_0);
    OUT_VAL (tile_1);
    OUT_VAL (tile_pos_0);

    OUT_VAL (sz_tilelist);
#endif

    return 0;
}

static void
version (FILE *out_stream)
{
    fprintf( out_stream, "Cube Creator for SSS version %d.%d\n", VERSION_MAJOR, VERSION_MINOR);
    fprintf( out_stream, "Copyright 2009 Yunhui Fu (yhfudev@gmail.com)\n\n" );
}

static void
help (FILE *out_stream, const char *progname)
{
    static const char *help_msg[] = {
        "Command line version of Cube (3D) Creator for Supertile Simulation System", 
        "",
        "-n --bits  <size>      specify the cube size",
        "-b --startbits <0-1bits string> the start binary bits",
        "-a --maxtiles  <size>      specify the maxium number of tiles",
        "-m --multiple  <multiple>  specify the number of target supertiles",
        "-t --temperature <temperature> replace the temperature of the system",
        "-o --outprefix <prefix>    specify the prefix of the output xml file",

        "-V --version               display version information",
        "   --help                  display this help",
        "-v --verbose               be verbose",
        0 };
   const char **p = help_msg;

   fprintf (out_stream, "Usage: %s [options]\n", progname);
   while (*p) fprintf (out_stream, "%s\n", *p++);
}

int
main (int argc, char *argv[])
{
    const char *fn_out = "testbintile";
    char *startbinary = NULL;
    char fname[300];
    size_t bits = 0;
    size_t sz_max_tiles = 0;
    size_t multiple = 0;
    size_t temperature = 2;
    int c;
    struct option longopts[]  = {
        { "bits", 1, 0, 'n' },
        { "startbin", 1, 0, 'b' },
        { "maxtiles",   1, 0, 'a' },
        { "multiple",   1, 0, 'm' },
        { "temperature",1, 0, 't' },
        { "outprefix",  1, 0, 'o' },
        { "version",    0, 0, 'V' },
        { "help",       0, 0, 501 },
        { "verbose",    0, 0, 'v' },
        { 0,            0, 0,  0  },
    };
    while ((c = getopt_long( argc, argv, "n:m:t:o:a:b:VLv", longopts, NULL )) != EOF) {
        switch (c) {
        case 'n': bits = atoi (optarg); break;
        case 'b': startbinary = optarg; break;
        case 'a': sz_max_tiles = atoi (optarg); break;
        case 'm': multiple = atoi (optarg); break;
        case 'o': fn_out = optarg; break;
        case 't': temperature = atoi (optarg); break;
        case 'V': version (stdout); exit(1); break;
        case 'v': break;
        default:
        case 501: help (stdout, argv[0]); exit(1); break;
        }
    }
    if (optind == argc) {
        if (0 == bits) {
            version (stderr);
            fprintf (stderr, "Use --help for help\n" );
            exit(1);
        }
    }
    if ((sz_max_tiles != 0) && (multiple != 0)) {
        version (stderr);
        fprintf (stderr, "Please specify --maxtiles or --multiple only once.\n" );
        exit(1);
    }
    if ((sz_max_tiles == 0) && (multiple == 0)) {
        multiple = 100;
    }
    if (sz_max_tiles == 0) {
        assert (multiple > 0);
        sz_max_tiles = multiple * pow (2, bits);
    }

    sprintf (fname, "%s_skeleton.xml", fn_out);
    printf ("output: '%s'\n", fname);
    if (out_bintile (bits, startbinary, sz_max_tiles, temperature, fname) < 0) {
        return 1;
    }

    return 0;
}
